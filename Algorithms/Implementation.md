# Implementation - 구현

> 머리 속에 있는 알고리즘을 코드로 구현하는 과정
> 
- 상당히 간단한 정의인데, 예시를 보면 감이 잡힌다.
    - 알고리즘은 간단한데 예외처리가 많은 문제
    - 특정 소수점 자리까지 출력하는 문제
    - 문자열 파싱 문제
- 이들은 크게 완전 탐색과 시뮬레이션으로 나뉠 수 있다. (다 그렇지는 않다.)

| 완전 탐색 | 시뮬레이션 |
| --- | --- |
| 모든 경우의 수를 다 계산 | 문제에서 제시한 알고리즘을 한 단계씩 직접 수행 |

## 구현에서 고려해야할 사항

1. <span style="color:red">메모리 제약 사항</span>
- 파이썬은 직접 자료형을 지정할 필요가 없기에 **매우 큰 수의 연산을 기본적으로 지원**한다.
- 따라서, 자료형 별 값의 범위, 크기를 `java` 기준으로 작성해 보겠다.

| 자료형 종류 | 자료형의 크기 | 자료형의 범위 |
| --- | --- | --- |
| byte | 1 B | -2^7 ~ 2^7 - 1 |
| short | 2 B | -2 ^ 15 ~ 2^15 - 1 |
| int | 4B | -2 ^ 31 ^ 2^31 - 1 |
| long | 8 B | -2^63 ~ 2^63 - 1 |
| float | 4 B (부동소수점) | -3.4e+38 ~ 3.4e+38 |
| double | 8 B (부동소수점) | -1.79e308 ~ 1.79e308 |
- <span style="color:red">참고로, java에는 unsigned 형이 없다.</span>

1. 실행 속도 (계산 복잡도)
- 코딩 테스트 환경에서는 파이썬이 <span style="color:red">**1초에 2000만번 연산을 수행**</span>한다고 가정하면 큰 무리가 없다.
    - 즉, 1초라는 시간 제약이 있는 문제에서, 계산 복잡도가 `O(Nlog(N))` 이라 할 때, 최대 연산 횟수가 100만이라면 문제가 없다.
    → `O(Nlog(N))` 에서 `N=1,000,000` 일 때, `20,000,000` 임


# <span style="color:red">문제 풀이 추가 예정...</span>